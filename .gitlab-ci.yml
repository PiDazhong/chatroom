stages:
  - test
  - build
  - deploy

# 代码检查阶段
lint:
  stage: test
  variables:
    GIT_STRATEGY: none # 禁用默认的代码拉取
  before_script:
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null # 添加私钥
    - mkdir -p ~/.ssh
    # 检查是否已经有主机密钥，如果没有则添加
    - grep -q "^gitlab.quantanalysis.cn" ~/.ssh/known_hosts || ssh-keyscan -p 2222 gitlab.quantanalysis.cn >> ~/.ssh/known_hosts
    # 创建一个基于分支名的文件夹，并进入该文件夹
    - mkdir -p $CI_COMMIT_REF_NAME
    - cd $CI_COMMIT_REF_NAME
    # 如果文件夹中没有代码，克隆，否则拉取更新
    - if [ -d ".git" ];
      then git remote set-url origin ssh://git@gitlab.quantanalysis.cn:2222/chatroom/chatroom.git &&
      git pull origin $CI_COMMIT_REF_NAME;
      else git clone --branch $CI_COMMIT_REF_NAME ssh://git@gitlab.quantanalysis.cn:2222/chatroom/chatroom.git .;
      fi
  script:
    - yarn install
    - yarn lint # 假设你使用的是 JavaScript 相关项目
  except:
    - tags # 排除在 tags 上运行

# 构建前端项目（只有 lint 通过且是 master 或 v 开头的分支时触发）
build_frontend:
  stage: build
  variables:
    GIT_STRATEGY: none # 禁用默认的代码拉取
  before_script:
    - cd $CI_COMMIT_REF_NAME # 进入对应的分支目录
  script:
    - yarn install
    - yarn just-build # 打包项目，生成静态文件
  artifacts:
    paths:
      - $CI_COMMIT_REF_NAME/chatroom/
  only:
    - master
    - /^v\d+\.\d+\.\d+$/
  dependencies:
    - lint # 确保 build 只在 lint 通过时触发

# 部署到服务器或静态托管服务
deploy_prod:
  stage: deploy
  variables:
    GIT_STRATEGY: none # 禁用默认的代码拉取
  script:
    # 进入对应分支的目录并打包文件
    - cd $CI_COMMIT_REF_NAME
    - tar -czf chatroom_$CI_COMMIT_REF_NAME.tar.gz chatroom/ # 将打包文件名与分支名称关联
    # 发送打包文件到服务器对应分支的目录
    - scp chatroom_$CI_COMMIT_REF_NAME.tar.gz root@47.120.40.71:/encrypt/$CI_COMMIT_REF_NAME/
    # 在服务器上创建分支目录并解压到对应的分支目录
    - ssh root@47.120.40.71 "mkdir -p /encrypt/$CI_COMMIT_REF_NAME && tar -xzf /encrypt/$CI_COMMIT_REF_NAME/chatroom_$CI_COMMIT_REF_NAME.tar.gz -C /encrypt/$CI_COMMIT_REF_NAME/"
  only:
    - master
    - /^v\d+\.\d+\.\d+$/
  dependencies:
    - build_frontend

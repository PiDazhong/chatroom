stages:
  - pipeline

# 构建并部署前端项目（lint 通过且是 master 或 v 开头的分支时触发）
build_and_deploy:
  stage: pipeline
  variables:
    # 禁用默认的代码拉取
    GIT_STRATEGY: none
  # 缓存 node_modules
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
  before_script:
    # 显示当前分支名称
    - echo "当前执行的分支是：$CI_COMMIT_REF_NAME"
    # 优化 SSH 密钥和主机密钥添加
    - |
      if [ ! -d ~/.ssh ]; then
        mkdir -p ~/.ssh
      fi
      eval $(ssh-agent -s)
      echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
      grep -q "^gitlab.quantanalysis.cn" ~/.ssh/known_hosts || ssh-keyscan -p 2222 gitlab.quantanalysis.cn >> ~/.ssh/known_hosts

    # 创建一个基于分支名的文件夹，并进入该文件夹
    - mkdir -p $CI_COMMIT_REF_NAME
    - cd $CI_COMMIT_REF_NAME

    # 如果文件夹中没有代码，克隆，否则拉取更新
    - if [ -d ".git" ]; then
      git remote set-url origin ssh://git@gitlab.quantanalysis.cn:2222/chatroom/chatroom.git && git pull origin $CI_COMMIT_REF_NAME;
      else
      git clone --branch $CI_COMMIT_REF_NAME ssh://git@gitlab.quantanalysis.cn:2222/chatroom/chatroom.git .;
      fi
  script:
    # 所有分支 都执行版本锁定的安装，并都执行 lint
    - yarn install --frozen-lockfile
    - yarn lint

    # 设置路径变量
    - export DEPLOY_DIR="/encrypt/$CI_COMMIT_REF_NAME"

    # 安装依赖并构建前端项目，只有 master 和 v 开头的分支才执行
    - |
      if [[ "$CI_COMMIT_REF_NAME" == "master" || "$CI_COMMIT_REF_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "当前分支 $CI_COMMIT_REF_NAME : 主分支或版本分支，执行编译和发布"
        yarn just-build

        # 将打包文件名与分支名称关联
        tar -czf chatroom_$CI_COMMIT_REF_NAME.tar.gz chatroom/

        # 远程操作：创建目录、传输文件、解压文件，合并 SSH 操作
        ssh root@47.120.40.71 "mkdir -p $DEPLOY_DIR && tar -xzf - -C $DEPLOY_DIR" < chatroom_$CI_COMMIT_REF_NAME.tar.gz
      else
        echo "当前分支 $CI_COMMIT_REF_NAME : 非主分支或版本分支，跳过编译和发布"
      fi

  artifacts:
    paths:
      - $CI_COMMIT_REF_NAME/chatroom/
